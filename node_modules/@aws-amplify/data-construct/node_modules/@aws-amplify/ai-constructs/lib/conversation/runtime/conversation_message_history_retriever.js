"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationMessageHistoryRetriever = void 0;
const graphql_request_executor_1 = require("./graphql_request_executor");
/**
 * These are all properties we have to pull.
 * Unfortunately, GQL doesn't support wildcards.
 * https://github.com/graphql/graphql-spec/issues/127
 */
const messageItemSelectionSet = `
                id
                conversationId
                associatedUserMessageId
                aiContext
                role
                content {
                  text
                  document {
                    source {
                      bytes
                    }
                    format
                    name
                  }
                  image {
                    format
                    source {
                      bytes
                    }
                  }
                  toolResult {
                    content {
                      document {
                        format
                        name
                        source {
                          bytes
                        }
                      }
                      image {
                        format
                        source {
                          bytes
                        }
                      }
                      json
                      text
                    }
                    status
                    toolUseId
                  }
                  toolUse {
                    input
                    name
                    toolUseId
                  }
                }
`;
/**
 * This class is responsible for retrieving message history that belongs to conversation turn event.
 * It queries AppSync to list messages that belong to conversation.
 * Additionally, it looks up a current message in case it's missing in the list due to eventual consistency.
 */
class ConversationMessageHistoryRetriever {
    /**
     * Creates conversation message history retriever.
     */
    constructor(event, graphqlRequestExecutor = new graphql_request_executor_1.GraphqlRequestExecutor(event.graphqlApiEndpoint, event.request.headers.authorization, event.request.headers['x-amz-user-agent'])) {
        this.event = event;
        this.graphqlRequestExecutor = graphqlRequestExecutor;
        this.getMessageHistory = async () => {
            const messages = await this.listMessages();
            let currentMessage = messages.find((m) => m.id === this.event.currentMessageId);
            // This is a fallback in case current message is not available in the message list.
            // I.e. in a situation when freshly written message is not yet visible in
            // eventually consistent reads.
            if (!currentMessage) {
                currentMessage = await this.getCurrentMessage();
                messages.push(currentMessage);
            }
            // Index assistant messages by corresponding user message.
            const assistantMessageByUserMessageId = new Map();
            messages.forEach((message) => {
                if (message.role === 'assistant' && message.associatedUserMessageId) {
                    assistantMessageByUserMessageId.set(message.associatedUserMessageId, message);
                }
            });
            // Reconcile history and inject aiContext
            const orderedMessages = messages.reduce((acc, current) => {
                // Bedrock expects that message history is user->assistant->user->assistant->... and so on.
                // The chronological order doesn't assure this ordering if there were any concurrent messages sent.
                // Therefore, conversation is ordered by user's messages only and corresponding assistant messages are inserted
                // into right place regardless of their createdAt value.
                // This algorithm assumes that GQL query returns messages sorted by createdAt.
                if (current.role === 'assistant') {
                    // Initially, skip assistant messages, these might be out of chronological order.
                    return acc;
                }
                if (current.role === 'user' &&
                    !assistantMessageByUserMessageId.has(current.id) &&
                    current.id !== this.event.currentMessageId) {
                    // Skip user messages that didn't get answer from assistant yet.
                    // These might be still "in-flight", i.e. assistant is still working on them in separate invocation.
                    // Except current message, we want to process that one.
                    return acc;
                }
                const aiContext = current.aiContext;
                const content = aiContext
                    ? [...current.content, { text: JSON.stringify(aiContext) }]
                    : current.content;
                acc.push({ role: current.role, content });
                // Find and insert corresponding assistant message.
                const correspondingAssistantMessage = assistantMessageByUserMessageId.get(current.id);
                if (correspondingAssistantMessage) {
                    acc.push({
                        role: correspondingAssistantMessage.role,
                        content: correspondingAssistantMessage.content,
                    });
                }
                return acc;
            }, []);
            // Remove tool usage from non-current turn and squash messages.
            return this.squashNonCurrentTurns(orderedMessages);
        };
        /**
         * This function removes tool usage from non-current turns.
         * The tool usage and result blocks don't matter after a turn is completed,
         * but do cost extra tokens to process.
         * The algorithm is as follows:
         * 1. Find where current turn begins. I.e. last user message that isn't tool block.
         * 2. Remove toolUse and toolResult blocks before current turn.
         * 3. Squash continuous sequences of messages that belong to same 'message.role'.
         */
        this.squashNonCurrentTurns = (messages) => {
            const isNonToolBlockPredicate = (contentBlock) => !contentBlock.toolUse && !contentBlock.toolResult;
            // find where current turn begins. I.e. last user message that is not related to tools
            const lastNonToolUseUserMessageIndex = messages.findLastIndex((message) => {
                return (message.role === 'user' && message.content.find(isNonToolBlockPredicate));
            });
            // No non-current turns, don't transform.
            if (lastNonToolUseUserMessageIndex <= 0) {
                return messages;
            }
            const squashedMessages = [];
            // Define a "buffer". I.e. a message we keep around and squash content on.
            let currentSquashedMessage = undefined;
            // Process messages before current turn begins
            // Remove tool usage blocks.
            // Combine content for consecutive message that have same role.
            for (let i = 0; i < lastNonToolUseUserMessageIndex; i++) {
                const currentMessage = messages[i];
                const currentMessageRole = currentMessage.role;
                const currentMessageNonToolContent = currentMessage.content.filter(isNonToolBlockPredicate);
                if (currentMessageNonToolContent.length === 0) {
                    // Tool only message. Nothing to squash, skip;
                    continue;
                }
                if (!currentSquashedMessage) {
                    // Nothing squashed yet, initialize the buffer.
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
                else if (currentSquashedMessage.role === currentMessageRole) {
                    // if role is same append content.
                    currentSquashedMessage.content.push(...currentMessageNonToolContent);
                }
                else {
                    // if role flips push current squashed message and re-initialize the buffer.
                    squashedMessages.push(currentSquashedMessage);
                    currentSquashedMessage = {
                        role: currentMessageRole,
                        content: currentMessageNonToolContent,
                    };
                }
            }
            // flush the last buffer.
            if (currentSquashedMessage) {
                squashedMessages.push(currentSquashedMessage);
            }
            // Append current turn as is.
            squashedMessages.push(...messages.slice(lastNonToolUseUserMessageIndex));
            return squashedMessages;
        };
        this.getCurrentMessage = async () => {
            const query = `
        query GetMessage($id: ${this.event.messageHistoryQuery.getQueryInputTypeName}!) {
            ${this.event.messageHistoryQuery.getQueryName}(id: $id) {
              ${messageItemSelectionSet}
            }
        }
    `;
            const variables = {
                id: this.event.currentMessageId,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            return response.data[this.event.messageHistoryQuery.getQueryName];
        };
        this.listMessages = async () => {
            var _a;
            const query = `
        query ListMessages($filter: ${this.event.messageHistoryQuery.listQueryInputTypeName}!, $limit: Int) {
            ${this.event.messageHistoryQuery.listQueryName}(filter: $filter, limit: $limit) {
              items {
                ${messageItemSelectionSet}
              }
            }
        }
    `;
            const variables = {
                filter: {
                    conversationId: {
                        eq: this.event.conversationId,
                    },
                },
                limit: (_a = this.event.messageHistoryQuery.listQueryLimit) !== null && _a !== void 0 ? _a : 1000,
            };
            const response = await this.graphqlRequestExecutor.executeGraphql({
                query,
                variables,
            });
            const items = response.data[this.event.messageHistoryQuery.listQueryName].items;
            items.forEach((item) => {
                var _a;
                (_a = item.content) === null || _a === void 0 ? void 0 : _a.forEach((contentBlock) => {
                    var _a, _b;
                    let property;
                    for (property in contentBlock) {
                        // Deserialization of GraphQl query result sets these properties to 'null'
                        // This can trigger Bedrock SDK validation as it expects 'undefined' if properties are not set.
                        // We can't fix how GraphQl response is deserialized.
                        // Therefore, we apply this transformation to fix the data.
                        if (contentBlock[property] === null) {
                            contentBlock[property] = undefined;
                        }
                    }
                    if (typeof ((_a = contentBlock.toolUse) === null || _a === void 0 ? void 0 : _a.input) === 'string') {
                        // toolUse.input may come as serialized JSON for Client Tools.
                        // Parse it in that case.
                        contentBlock.toolUse.input = JSON.parse(contentBlock.toolUse.input);
                    }
                    if ((_b = contentBlock.toolResult) === null || _b === void 0 ? void 0 : _b.content) {
                        contentBlock.toolResult.content.forEach((toolResultContentBlock) => {
                            if (typeof toolResultContentBlock.json === 'string') {
                                // toolResult.content[].json may come as serialized JSON for Client Tools.
                                // Parse it in that case.
                                toolResultContentBlock.json = JSON.parse(toolResultContentBlock.json);
                            }
                        });
                    }
                });
            });
            return items;
        };
    }
}
exports.ConversationMessageHistoryRetriever = ConversationMessageHistoryRetriever;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udmVyc2F0aW9uL3J1bnRpbWUvY29udmVyc2F0aW9uX21lc3NhZ2VfaGlzdG9yeV9yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBS0EseUVBQW9FO0FBbUNwRTs7OztHQUlHO0FBQ0gsTUFBTSx1QkFBdUIsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0QvQixDQUFDO0FBRUY7Ozs7R0FJRztBQUNILE1BQWEsbUNBQW1DO0lBQzlDOztPQUVHO0lBQ0gsWUFDbUIsS0FBNEIsRUFDNUIseUJBQXlCLElBQUksaURBQXNCLENBQ2xFLEtBQUssQ0FBQyxrQkFBa0IsRUFDeEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUNuQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUMxQztRQUxnQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUM1QiwyQkFBc0IsR0FBdEIsc0JBQXNCLENBSXRDO1FBR0gsc0JBQWlCLEdBQUcsS0FBSyxJQUF5QyxFQUFFO1lBQ2xFLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBRTNDLElBQUksY0FBYyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQ2hDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQzVDLENBQUM7WUFFRixtRkFBbUY7WUFDbkYseUVBQXlFO1lBQ3pFLCtCQUErQjtZQUMvQixJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUNuQixjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDaEQsUUFBUSxD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akUsSUFBSSxPQUFPLHNCQUFzQixDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7Z0NBQ25ELDBFQUEwRTtnQ0FDMUUseUJBQXlCO2dDQUN6QixzQkFBc0IsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FDdEMsc0JBQXNCLENBQUMsSUFBSSxDQUM1QixDQUFDOzZCQUNIO3dCQUNILENBQUMsQ0FBQyxDQUFDO3FCQUNKO2dCQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUMsQ0FBQztJQTdPQyxDQUFDO0NBOE9MO0FBelBELGtGQXlQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbnZlcnNhdGlvbk1lc3NhZ2UsXG4gIENvbnZlcnNhdGlvbk1lc3NhZ2VDb250ZW50QmxvY2ssXG4gIENvbnZlcnNhdGlvblR1cm5FdmVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBHcmFwaHFsUmVxdWVzdEV4ZWN1dG9yIH0gZnJvbSAnLi9ncmFwaHFsX3JlcXVlc3RfZXhlY3V0b3InO1xuXG5leHBvcnQgdHlwZSBDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0gPSBDb252ZXJzYXRpb25NZXNzYWdlICYge1xuICBpZDogc3RyaW5nO1xuICBjb252ZXJzYXRpb25JZDogc3RyaW5nO1xuICBhc3NvY2lhdGVkVXNlck1lc3NhZ2VJZD86IHN0cmluZztcbiAgYWlDb250ZXh0PzogdW5rbm93bjtcbn07XG5cbmV4cG9ydCB0eXBlIEdldFF1ZXJ5SW5wdXQgPSB7XG4gIGlkOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBHZXRRdWVyeU91dHB1dCA9IHtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPjtcbn07XG5cbmV4cG9ydCB0eXBlIExpc3RRdWVyeUlucHV0ID0ge1xuICBmaWx0ZXI6IHtcbiAgICBjb252ZXJzYXRpb25JZDoge1xuICAgICAgZXE6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBsaW1pdDogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgTGlzdFF1ZXJ5T3V0cHV0ID0ge1xuICBkYXRhOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHtcbiAgICAgIGl0ZW1zOiBBcnJheTxDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0+O1xuICAgIH1cbiAgPjtcbn07XG5cbi8qKlxuICogVGhlc2UgYXJlIGFsbCBwcm9wZXJ0aWVzIHdlIGhhdmUgdG8gcHVsbC5cbiAqIFVuZm9ydHVuYXRlbHksIEdRTCBkb2Vzbid0IHN1cHBvcnQgd2lsZGNhcmRzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1zcGVjL2lzc3Vlcy8xMjdcbiAqL1xuY29uc3QgbWVzc2FnZUl0ZW1TZWxlY3Rpb25TZXQgPSBgXG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZFxuICAgICAgICAgICAgICAgIGFzc29jaWF0ZWRVc2VyTWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgYWlDb250ZXh0XG4gICAgICAgICAgICAgICAgcm9sZVxuICAgICAgICAgICAgICAgIGNvbnRlbnQge1xuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGltYWdlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQge1xuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBqc29uXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRvb2xVc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRvb2xVc2VJZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbmA7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmV0cmlldmluZyBtZXNzYWdlIGhpc3RvcnkgdGhhdCBiZWxvbmdzIHRvIGNvbnZlcnNhdGlvbiB0dXJuIGV2ZW50LlxuICogSXQgcXVlcmllcyBBcHBTeW5jIHRvIGxpc3QgbWVzc2FnZXMgdGhhdCBiZWxvbmcgdG8gY29udmVyc2F0aW9uLlxuICogQWRkaXRpb25hbGx5LCBpdCBsb29rcyB1cCBhIGN1cnJlbnQgbWVzc2FnZSBpbiBjYXNlIGl0J3MgbWlzc2luZyBpbiB0aGUgbGlzdCBkdWUgdG8gZXZlbnR1YWwgY29uc2lzdGVuY3kuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb252ZXJzYXRpb25NZXNzYWdlSGlzdG9yeVJldHJpZXZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGNvbnZlcnNhdGlvbiBtZXNzYWdlIGhpc3RvcnkgcmV0cmlldmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBldmVudDogQ29udmVyc2F0aW9uVHVybkV2ZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ3JhcGhxbFJlcXVlc3RFeGVjdXRvciA9IG5ldyBHcmFwaHFsUmVxdWVzdEV4ZWN1dG9yKFxuICAgICAgZXZlbnQuZ3JhcGhxbEFwaUVuZHBvaW50LFxuICAgICAgZXZlbnQucmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24sXG4gICAgICBldmVudC5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXVzZXItYWdlbnQnXVxuICAgIClcbiAgKSB7fVxuXG4gIGdldE1lc3NhZ2VIaXN0b3J5ID0gYXN5bmMgKCk6IFByb21pc2U8QXJyYXk8Q29udmVyc2F0aW9uTWVzc2FnZT4+ID0+IHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IHRoaXMubGlzdE1lc3NhZ2VzKCk7XG5cbiAgICBsZXQgY3VycmVudE1lc3NhZ2UgPSBtZXNzYWdlcy5maW5kKFxuICAgICAgKG0pID0+IG0uaWQgPT09IHRoaXMuZXZlbnQuY3VycmVudE1lc3NhZ2VJZFxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZmFsbGJhY2sgaW4gY2FzZSBjdXJyZW50IG1lc3NhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgbWVzc2FnZSBsaXN0LlxuICAgIC8vIEkuZS4gaW4gYSBzaXR1YXRpb24gd2hlbiBmcmVzaGx5IHdyaXR0ZW4gbWVzc2FnZSBpcyBub3QgeWV0IHZpc2libGUgaW5cbiAgICAvLyBldmVudHVhbGx5IGNvbnNpc3RlbnQgcmVhZHMuXG4gICAgaWYgKCFjdXJyZW50TWVzc2FnZSkge1xuICAgICAgY3VycmVudE1lc3NhZ2UgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRNZXNzYWdlKCk7XG4gICAgICBtZXNzYWdlcy5wdXNoKGN1cnJlbnRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyBJbmRleCBhc3Npc3RhbnQgbWVzc2FnZXMgYnkgY29ycmVzcG9uZGluZyB1c2VyIG1lc3NhZ2UuXG4gICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZDogTWFwPFxuICAgICAgc3RyaW5nLFxuICAgICAgQ29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtXG4gICAgPiA9IG5ldyBNYXAoKTtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBtZXNzYWdlLmFzc29jaWF0ZWRVc2VyTWVzc2FnZUlkKSB7XG4gICAgICAgIGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuc2V0KFxuICAgICAgICAgIG1lc3NhZ2UuYXNzb2NpYXRlZFVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgbWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVjb25jaWxlIGhpc3RvcnkgYW5kIGluamVjdCBhaUNvbnRleHRcbiAgICBjb25zdCBvcmRlcmVkTWVzc2FnZXMgPSBtZXNzYWdlcy5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgLy8gQmVkcm9jayBleHBlY3RzIHRoYXQgbWVzc2FnZSBoaXN0b3J5IGlzIHVzZXItPmFzc2lzdGFudC0+dXNlci0+YXNzaXN0YW50LT4uLi4gYW5kIHNvIG9uLlxuICAgICAgLy8gVGhlIGNocm9ub2xvZ2ljYWwgb3JkZXIgZG9lc24ndCBhc3N1cmUgdGhpcyBvcmRlcmluZyBpZiB0aGVyZSB3ZXJlIGFueSBjb25jdXJyZW50IG1lc3NhZ2VzIHNlbnQuXG4gICAgICAvLyBUaGVyZWZvcmUsIGNvbnZlcnNhdGlvbiBpcyBvcmRlcmVkIGJ5IHVzZXIncyBtZXNzYWdlcyBvbmx5IGFuZCBjb3JyZXNwb25kaW5nIGFzc2lzdGFudCBtZXNzYWdlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gcmlnaHQgcGxhY2UgcmVnYXJkbGVzcyBvZiB0aGVpciBjcmVhdGVkQXQgdmFsdWUuXG4gICAgICAvLyBUaGlzIGFsZ29yaXRobSBhc3N1bWVzIHRoYXQgR1FMIHF1ZXJ5IHJldHVybnMgbWVzc2FnZXMgc29ydGVkIGJ5IGNyZWF0ZWRBdC5cbiAgICAgIGlmIChjdXJyZW50LnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIC8vIEluaXRpYWxseSwgc2tpcCBhc3Npc3RhbnQgbWVzc2FnZXMsIHRoZXNlIG1pZ2h0IGJlIG91dCBvZiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50LnJvbGUgPT09ICd1c2VyJyAmJlxuICAgICAgICAhYXNzaXN0YW50TWVzc2FnZUJ5VXNlck1lc3NhZ2VJZC5oYXMoY3VycmVudC5pZCkgJiZcbiAgICAgICAgY3VycmVudC5pZCAhPT0gdGhpcy5ldmVudC5jdXJyZW50TWVzc2FnZUlkXG4gICAgICApIHtcbiAgICAgICAgLy8gU2tpcCB1c2VyIG1lc3NhZ2VzIHRoYXQgZGlkbid0IGdldCBhbnN3ZXIgZnJvbSBhc3Npc3RhbnQgeWV0LlxuICAgICAgICAvLyBUaGVzZSBtaWdodCBiZSBzdGlsbCBcImluLWZsaWdodFwiLCBpLmUuIGFzc2lzdGFudCBpcyBzdGlsbCB3b3JraW5nIG9uIHRoZW0gaW4gc2VwYXJhdGUgaW52b2NhdGlvbi5cbiAgICAgICAgLy8gRXhjZXB0IGN1cnJlbnQgbWVzc2FnZSwgd2Ugd2FudCB0byBwcm9jZXNzIHRoYXQgb25lLlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3QgYWlDb250ZXh0ID0gY3VycmVudC5haUNvbnRleHQ7XG4gICAgICBjb25zdCBjb250ZW50ID0gYWlDb250ZXh0XG4gICAgICAgID8gWy4uLmN1cnJlbnQuY29udGVudCwgeyB0ZXh0OiBKU09OLnN0cmluZ2lmeShhaUNvbnRleHQpIH1dXG4gICAgICAgIDogY3VycmVudC5jb250ZW50O1xuXG4gICAgICBhY2MucHVzaCh7IHJvbGU6IGN1cnJlbnQucm9sZSwgY29udGVudCB9KTtcblxuICAgICAgLy8gRmluZCBhbmQgaW5zZXJ0IGNvcnJlc3BvbmRpbmcgYXNzaXN0YW50IG1lc3NhZ2UuXG4gICAgICBjb25zdCBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZSA9IGFzc2lzdGFudE1lc3NhZ2VCeVVzZXJNZXNzYWdlSWQuZ2V0KFxuICAgICAgICBjdXJyZW50LmlkXG4gICAgICApO1xuICAgICAgaWYgKGNvcnJlc3BvbmRpbmdBc3Npc3RhbnRNZXNzYWdlKSB7XG4gICAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBjb3JyZXNwb25kaW5nQXNzaXN0YW50TWVzc2FnZS5yb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvcnJlc3BvbmRpbmdBc3Npc3RhbnRNZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSBhcyBBcnJheTxDb252ZXJzYXRpb25NZXNzYWdlPik7XG5cbiAgICAvLyBSZW1vdmUgdG9vbCB1c2FnZSBmcm9tIG5vbi1jdXJyZW50IHR1cm4gYW5kIHNxdWFzaCBtZXNzYWdlcy5cbiAgICByZXR1cm4gdGhpcy5zcXVhc2hOb25DdXJyZW50VHVybnMob3JkZXJlZE1lc3NhZ2VzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRvb2wgdXNhZ2UgZnJvbSBub24tY3VycmVudCB0dXJucy5cbiAgICogVGhlIHRvb2wgdXNhZ2UgYW5kIHJlc3VsdCBibG9ja3MgZG9uJ3QgbWF0dGVyIGFmdGVyIGEgdHVybiBpcyBjb21wbGV0ZWQsXG4gICAqIGJ1dCBkbyBjb3N0IGV4dHJhIHRva2VucyB0byBwcm9jZXNzLlxuICAgKiBUaGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gICAqIDEuIEZpbmQgd2hlcmUgY3VycmVudCB0dXJuIGJlZ2lucy4gSS5lLiBsYXN0IHVzZXIgbWVzc2FnZSB0aGF0IGlzbid0IHRvb2wgYmxvY2suXG4gICAqIDIuIFJlbW92ZSB0b29sVXNlIGFuZCB0b29sUmVzdWx0IGJsb2NrcyBiZWZvcmUgY3VycmVudCB0dXJuLlxuICAgKiAzLiBTcXVhc2ggY29udGludW91cyBzZXF1ZW5jZXMgb2YgbWVzc2FnZXMgdGhhdCBiZWxvbmcgdG8gc2FtZSAnbWVzc2FnZS5yb2xlJy5cbiAgICovXG4gIHByaXZhdGUgc3F1YXNoTm9uQ3VycmVudFR1cm5zID0gKG1lc3NhZ2VzOiBBcnJheTxDb252ZXJzYXRpb25NZXNzYWdlPikgPT4ge1xuICAgIGNvbnN0IGlzTm9uVG9vbEJsb2NrUHJlZGljYXRlID0gKFxuICAgICAgY29udGVudEJsb2NrOiBDb252ZXJzYXRpb25NZXNzYWdlQ29udGVudEJsb2NrXG4gICAgKSA9PiAhY29udGVudEJsb2NrLnRvb2xVc2UgJiYgIWNvbnRlbnRCbG9jay50b29sUmVzdWx0O1xuXG4gICAgLy8gZmluZCB3aGVyZSBjdXJyZW50IHR1cm4gYmVnaW5zLiBJLmUuIGxhc3QgdXNlciBtZXNzYWdlIHRoYXQgaXMgbm90IHJlbGF0ZWQgdG8gdG9vbHNcbiAgICBjb25zdCBsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPSBtZXNzYWdlcy5maW5kTGFzdEluZGV4KChtZXNzYWdlKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJyAmJiBtZXNzYWdlLmNvbnRlbnQuZmluZChpc05vblRvb2xCbG9ja1ByZWRpY2F0ZSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyBObyBub24tY3VycmVudCB0dXJucywgZG9uJ3QgdHJhbnNmb3JtLlxuICAgIGlmIChsYXN0Tm9uVG9vbFVzZVVzZXJNZXNzYWdlSW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cblxuICAgIGNvbnN0IHNxdWFzaGVkTWVzc2FnZXM6IEFycmF5PENvbnZlcnNhdGlvbk1lc3NhZ2U+ID0gW107XG5cbiAgICAvLyBEZWZpbmUgYSBcImJ1ZmZlclwiLiBJLmUuIGEgbWVzc2FnZSB3ZSBrZWVwIGFyb3VuZCBhbmQgc3F1YXNoIGNvbnRlbnQgb24uXG4gICAgbGV0IGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2U6IENvbnZlcnNhdGlvbk1lc3NhZ2UgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgLy8gUHJvY2VzcyBtZXNzYWdlcyBiZWZvcmUgY3VycmVudCB0dXJuIGJlZ2luc1xuICAgIC8vIFJlbW92ZSB0b29sIHVzYWdlIGJsb2Nrcy5cbiAgICAvLyBDb21iaW5lIGNvbnRlbnQgZm9yIGNvbnNlY3V0aXZlIG1lc3NhZ2UgdGhhdCBoYXZlIHNhbWUgcm9sZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3ROb25Ub29sVXNlVXNlck1lc3NhZ2VJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VSb2xlID0gY3VycmVudE1lc3NhZ2Uucm9sZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQgPSBjdXJyZW50TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgaXNOb25Ub29sQmxvY2tQcmVkaWNhdGVcbiAgICAgICk7XG4gICAgICBpZiAoY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVG9vbCBvbmx5IG1lc3NhZ2UuIE5vdGhpbmcgdG8gc3F1YXNoLCBza2lwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc3F1YXNoZWQgeWV0LCBpbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgcm9sZTogY3VycmVudE1lc3NhZ2VSb2xlLFxuICAgICAgICAgIGNvbnRlbnQ6IGN1cnJlbnRNZXNzYWdlTm9uVG9vbENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTcXVhc2hlZE1lc3NhZ2Uucm9sZSA9PT0gY3VycmVudE1lc3NhZ2VSb2xlKSB7XG4gICAgICAgIC8vIGlmIHJvbGUgaXMgc2FtZSBhcHBlbmQgY29udGVudC5cbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4uY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiByb2xlIGZsaXBzIHB1c2ggY3VycmVudCBzcXVhc2hlZCBtZXNzYWdlIGFuZCByZS1pbml0aWFsaXplIHRoZSBidWZmZXIuXG4gICAgICAgIHNxdWFzaGVkTWVzc2FnZXMucHVzaChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKTtcbiAgICAgICAgY3VycmVudFNxdWFzaGVkTWVzc2FnZSA9IHtcbiAgICAgICAgICByb2xlOiBjdXJyZW50TWVzc2FnZVJvbGUsXG4gICAgICAgICAgY29udGVudDogY3VycmVudE1lc3NhZ2VOb25Ub29sQ29udGVudCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxhc3QgYnVmZmVyLlxuICAgIGlmIChjdXJyZW50U3F1YXNoZWRNZXNzYWdlKSB7XG4gICAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goY3VycmVudFNxdWFzaGVkTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIGN1cnJlbnQgdHVybiBhcyBpcy5cbiAgICBzcXVhc2hlZE1lc3NhZ2VzLnB1c2goLi4ubWVzc2FnZXMuc2xpY2UobGFzdE5vblRvb2xVc2VVc2VyTWVzc2FnZUluZGV4KSk7XG4gICAgcmV0dXJuIHNxdWFzaGVkTWVzc2FnZXM7XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50TWVzc2FnZSA9XG4gICAgYXN5bmMgKCk6IFByb21pc2U8Q29udmVyc2F0aW9uSGlzdG9yeU1lc3NhZ2VJdGVtPiA9PiB7XG4gICAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgcXVlcnkgR2V0TWVzc2FnZSgkaWQ6ICR7dGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5LmdldFF1ZXJ5SW5wdXRUeXBlTmFtZX0hKSB7XG4gICAgICAgICAgICAke3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWV9KGlkOiAkaWQpIHtcbiAgICAgICAgICAgICAgJHttZXNzYWdlSXRlbVNlbGVjdGlvblNldH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGA7XG4gICAgICBjb25zdCB2YXJpYWJsZXM6IEdldFF1ZXJ5SW5wdXQgPSB7XG4gICAgICAgIGlkOiB0aGlzLmV2ZW50LmN1cnJlbnRNZXNzYWdlSWQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ3JhcGhxbFJlcXVlc3RFeGVjdXRvci5leGVjdXRlR3JhcGhxbDxcbiAgICAgICAgR2V0UXVlcnlJbnB1dCxcbiAgICAgICAgR2V0UXVlcnlPdXRwdXRcbiAgICAgID4oe1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhW3RoaXMuZXZlbnQubWVzc2FnZUhpc3RvcnlRdWVyeS5nZXRRdWVyeU5hbWVdO1xuICAgIH07XG5cbiAgcHJpdmF0ZSBsaXN0TWVzc2FnZXMgPSBhc3luYyAoKTogUHJvbWlzZTxcbiAgICBBcnJheTxDb252ZXJzYXRpb25IaXN0b3J5TWVzc2FnZUl0ZW0+XG4gID4gPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYFxuICAgICAgICBxdWVyeSBMaXN0TWVzc2FnZXMoJGZpbHRlcjogJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5SW5wdXRUeXBlTmFtZX0hLCAkbGltaXQ6IEludCkge1xuICAgICAgICAgICAgJHt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZX0oZmlsdGVyOiAkZmlsdGVyLCBsaW1pdDogJGxpbWl0KSB7XG4gICAgICAgICAgICAgIGl0ZW1zIHtcbiAgICAgICAgICAgICAgICAke21lc3NhZ2VJdGVtU2VsZWN0aW9uU2V0fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IHZhcmlhYmxlczogTGlzdFF1ZXJ5SW5wdXQgPSB7XG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IHtcbiAgICAgICAgICBlcTogdGhpcy5ldmVudC5jb252ZXJzYXRpb25JZCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBsaW1pdDogdGhpcy5ldmVudC5tZXNzYWdlSGlzdG9yeVF1ZXJ5Lmxpc3RRdWVyeUxpbWl0ID8/IDEwMDAsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ncmFwaHFsUmVxdWVzdEV4ZWN1dG9yLmV4ZWN1dGVHcmFwaHFsPFxuICAgICAgTGlzdFF1ZXJ5SW5wdXQsXG4gICAgICBMaXN0UXVlcnlPdXRwdXRcbiAgICA+KHtcbiAgICAgIHF1ZXJ5LFxuICAgICAgdmFyaWFibGVzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgcmVzcG9uc2UuZGF0YVt0aGlzLmV2ZW50Lm1lc3NhZ2VIaXN0b3J5UXVlcnkubGlzdFF1ZXJ5TmFtZV0uaXRlbXM7XG5cbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmNvbnRlbnQ/LmZvckVhY2goKGNvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICBsZXQgcHJvcGVydHk6IGtleW9mIHR5cGVvZiBjb250ZW50QmxvY2s7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gY29udGVudEJsb2NrKSB7XG4gICAgICAgICAgLy8gRGVzZXJpYWxpemF0aW9uIG9mIEdyYXBoUWwgcXVlcnkgcmVzdWx0IHNldHMgdGhlc2UgcHJvcGVydGllcyB0byAnbnVsbCdcbiAgICAgICAgICAvLyBUaGlzIGNhbiB0cmlnZ2VyIEJlZHJvY2sgU0RLIHZhbGlkYXRpb24gYXMgaXQgZXhwZWN0cyAndW5kZWZpbmVkJyBpZiBwcm9wZXJ0aWVzIGFyZSBub3Qgc2V0LlxuICAgICAgICAgIC8vIFdlIGNhbid0IGZpeCBob3cgR3JhcGhRbCByZXNwb25zZSBpcyBkZXNlcmlhbGl6ZWQuXG4gICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBhcHBseSB0aGlzIHRyYW5zZm9ybWF0aW9uIHRvIGZpeCB0aGUgZGF0YS5cbiAgICAgICAgICBpZiAoY29udGVudEJsb2NrW3Byb3BlcnR5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGVudEJsb2NrW3Byb3BlcnR5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRCbG9jay50b29sVXNlPy5pbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyB0b29sVXNlLmlucHV0IG1heSBjb21lIGFzIHNlcmlhbGl6ZWQgSlNPTiBmb3IgQ2xpZW50IFRvb2xzLlxuICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICBjb250ZW50QmxvY2sudG9vbFVzZS5pbnB1dCA9IEpTT04ucGFyc2UoY29udGVudEJsb2NrLnRvb2xVc2UuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50QmxvY2sudG9vbFJlc3VsdD8uY29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnRCbG9jay50b29sUmVzdWx0LmNvbnRlbnQuZm9yRWFjaCgodG9vbFJlc3VsdENvbnRlbnRCbG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIHRvb2xSZXN1bHQuY29udGVudFtdLmpzb24gbWF5IGNvbWUgYXMgc2VyaWFsaXplZCBKU09OIGZvciBDbGllbnQgVG9vbHMuXG4gICAgICAgICAgICAgIC8vIFBhcnNlIGl0IGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdENvbnRlbnRCbG9jay5qc29uID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICB0b29sUmVzdWx0Q29udGVudEJsb2NrLmpzb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG59XG4iXX0=